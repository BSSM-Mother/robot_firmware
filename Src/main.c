/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE for Visual Studio Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "motor.h"

// 레지스터 정의
#define RCC_BASE           0x40021000
#define GPIOA_BASE         0x40010800
#define GPIOB_BASE         0x40010C00
#define USART1_BASE        0x40013800
#define USART2_BASE        0x40004400
#define TIM1_BASE          0x40012C00
#define TIM3_BASE          0x40000400

// RCC 레지스터
typedef struct {
    volatile uint32_t CR;
    volatile uint32_t CFGR;
    volatile uint32_t CIR;
    volatile uint32_t APB2RSTR;
    volatile uint32_t APB1RSTR;
    volatile uint32_t AHBENR;
    volatile uint32_t APB2ENR;
    volatile uint32_t APB1ENR;
} RCC_TypeDef;

// GPIO 레지스터
typedef struct {
    volatile uint32_t CRL;
    volatile uint32_t CRH;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
    volatile uint32_t BSRR;
    volatile uint32_t BRR;
    volatile uint32_t LCKR;
} GPIO_TypeDef;

// USART 레지스터
typedef struct {
    volatile uint32_t SR;
    volatile uint32_t DR;
    volatile uint32_t BRR;
    volatile uint32_t CR1;
    volatile uint32_t CR2;
    volatile uint32_t CR3;
    volatile uint32_t GTPR;
} USART_TypeDef;

// Timer 레지스터
typedef struct {
    volatile uint32_t CR1;
    volatile uint32_t CR2;
    volatile uint32_t SMCR;
    volatile uint32_t DIER;
    volatile uint32_t SR;
    volatile uint32_t EGR;
    volatile uint32_t CCMR1;
    volatile uint32_t CCMR2;
    volatile uint32_t CCER;
    volatile uint32_t CNT;
    volatile uint32_t PSC;
    volatile uint32_t ARR;
    volatile uint32_t RCR;
    volatile uint32_t CCR1;
    volatile uint32_t CCR2;
    volatile uint32_t CCR3;
    volatile uint32_t CCR4;
    volatile uint32_t BDTR;
} TIM_TypeDef;

#define RCC   ((RCC_TypeDef *)RCC_BASE)
#define GPIOA ((GPIO_TypeDef *)GPIOA_BASE)
#define GPIOB ((GPIO_TypeDef *)GPIOB_BASE)
#define USART1 ((USART_TypeDef *)USART1_BASE)
#define USART2 ((USART_TypeDef *)USART2_BASE)
// 보드별 UART 선택
#if defined(BOARD_BLUEPILL)
#define USARTx USART1
#else
#define USARTx USART2
#endif
#define TIM1  ((TIM_TypeDef *)TIM1_BASE)
#define TIM3  ((TIM_TypeDef *)TIM3_BASE)

// UART 버퍼
#define UART_BUFFER_SIZE 64
char uart_buffer[UART_BUFFER_SIZE];
int uart_idx = 0;

// 모터 상태
motor_state_t motor_state = {0, 0};

// 시스템 클럭 초기화 (HSI 8MHz 사용)
void system_clock_init(void)
{
    // HSI를 그대로 사용 (8MHz)
    RCC->CR |= (1 << 0);  // HSION
    while (!(RCC->CR & (1 << 1)));  // HSIRDY 대기
    
    // APB1, APB2 분주 없음 (모두 8MHz)
    RCC->CFGR = 0x00;  // 모든 분주기 비활성화
}

// UART 초기화 (115200 baud, 8N1)
void uart_init(void)
{
    // GPIOA 클럭 활성화
    RCC->APB2ENR |= (1 << 2);  // IOPAEN

#if defined(BOARD_BLUEPILL)
    // USART1 클럭 활성화 (APB2)
    RCC->APB2ENR |= (1 << 14); // USART1EN

    // PA9(TX): AF_PP, PA10(RX): In_Floating
    GPIOA->CRH &= ~(0xFF << 4); // PA9, PA10 클리어 (bits 4-11)
    GPIOA->CRH |= (0x0B << 4) | (0x04 << 8);  // PA9=1011(AF_PP,50MHz), PA10=0100(In_Floating)
#else
    // USART2 클럭 활성화 (APB1)
    RCC->APB1ENR |= (1 << 17); // USART2EN

    // PA2(TX): AF_PP, PA3(RX): In_Floating
    GPIOA->CRL &= ~(0xFF << 8); // PA2, PA3 클리어 (bits 8-15)
    GPIOA->CRL |= (0x0B << 8) | (0x04 << 12);  // PA2=1011(AF_PP,50MHz), PA3=0100(In_Floating)
#endif

    // USART 설정: 115200 baud
    // APB = 8MHz (HSI, 분주 없음)
    // USARTDIV = 8000000 / (16 * 115200) = 4.34
    // Mantissa = 4, Fraction = 0.34 * 16 = 5.44 ≈ 5
    // BRR = (4 << 4) | 5 = 0x45
    USARTx->BRR = 0x45;
    USARTx->CR1 = (1 << 3) | (1 << 2) | (1 << 13); // TE, RE, UE (인터럽트 없음)
    USARTx->CR2 = 0;
    USARTx->CR3 = 0;
}

// GPIO 초기화 (모터 제어 핀)
void gpio_init(void)
{
    // GPIOA, GPIOB 클럭 활성화
    RCC->APB2ENR |= (1 << 2) | (1 << 3);  // IOPAEN, IOPBEN
    
    // PA7, PA8: PWM 출력 (TIM3, TIM1)
    // PA7: TIM3_CH2, PA8: TIM1_CH1
    GPIOA->CRL &= ~(0xF << 28);  // PA7 클리어
    GPIOA->CRL |= (0x0B << 28);  // PA7: AF_PP, 50MHz
    GPIOA->CRH &= ~(0x0F);       // PA8 클리어
    GPIOA->CRH |= (0x0B);        // PA8: AF_PP, 50MHz
    
    // PB0-PB3: GPIO 출력 (IN1, IN2, IN3, IN4)
    GPIOB->CRL &= ~(0xFFFF);     // PB0-3 클리어
    GPIOB->CRL |= (0x1111);      // PB0-3: General purpose output, 10MHz
}

// Timer 초기화 (PWM 생성)
void timer_init(void)
{
    // TIM1 클럭 활성화
    RCC->APB2ENR |= (1 << 11);   // TIM1EN
    // TIM3 클럭 활성화
    RCC->APB1ENR |= (1 << 1);    // TIM3EN
    
    // TIM1 설정 (PA8 - CCR1) - 8MHz 기준
    TIM1->PSC = 7;               // 분주: 8MHz / 8 = 1MHz
    TIM1->ARR = 255;             // PWM 주기: 255
    TIM1->CCMR1 = (0x6 << 4) | (0x6 << 12); // CH1, CH2 PWM mode 1
    TIM1->CCER = (1 << 0) | (1 << 4); // CH1, CH2 활성화
    TIM1->BDTR = (1 << 15);      // MOE (Main Output Enable)
    TIM1->CR1 = 1;               // Timer 시작
    
    // TIM3 설정 (PA7 - CCR2) - 8MHz 기준
    TIM3->PSC = 7;               // 분주: 8MHz / 8 = 1MHz
    TIM3->ARR = 255;             // PWM 주기: 255
    TIM3->CCMR1 = (0x6 << 12);   // CH2 PWM mode 1
    TIM3->CCER = (1 << 4);       // CH2 활성화
    TIM3->CR1 = 1;               // Timer 시작
}

// 문자 하나 전송
void uart_putchar(char c)
{
    while (!(USARTx->SR & (1 << 7))); // TXE 대기
    USARTx->DR = c;
}

// 문자열 전송
void uart_puts(const char *str)
{
    while (*str)
        uart_putchar(*str++);
}

// UART 데이터 수신 및 처리
void uart_rx_handler(void)
{
    // 모든 수신 데이터를 빠르게 처리
    while (USARTx->SR & (1 << 5)) // RXNE
    {
        char c = USARTx->DR;
        
        // 에코 (디버깅)
        uart_putchar(c);
        
        if (c == '\n' || c == '\r')
        {
            uart_buffer[uart_idx] = '\0';
            
            if (uart_idx > 0) // 빈 줄 무시
            {
                uart_puts("\r\n[CMD:");
                uart_puts(uart_buffer);
                uart_puts("]\r\n");
                
                // 데이터 파싱: "speed,left_dir,right_dir" 형식
                // 예: "100,1,2" = 속도100, 왼쪽전진, 오른쪽후진
                parse_motor_command(uart_buffer);
            }
            
            uart_idx = 0;
        }
        else if (uart_idx < UART_BUFFER_SIZE - 1)
        {
            uart_buffer[uart_idx++] = c;
        }
        else
        {
            uart_idx = 0;
        }
    }
}

// 모터 제어 명령 파싱
void parse_motor_command(const char *cmd)
{
    // 예상 형식: "speed,left_dir,right_dir"
    // 예: "100,1,2" = 속도100, 왼쪽전진(1), 오른쪽후진(2)
    int speed = 0, left_dir = 0, right_dir = 0;
    char *ptr = (char *)cmd;
    
    // 속도 파싱
    speed = atoi(ptr);
    
    // 첫 번째 쉼표 찾기
    while (*ptr && *ptr != ',') ptr++;
    if (*ptr == ',') ptr++;
    
    // 왼쪽 방향 파싱
    left_dir = atoi(ptr);
    
    // 두 번째 쉼표 찾기
    while (*ptr && *ptr != ',') ptr++;
    if (*ptr == ',') ptr++;
    
    // 오른쪽 방향 파싱
    right_dir = atoi(ptr);
    
    // 속도 범위 제한 (0~255)
    if (speed > 255) speed = 255;
    if (speed < 0) speed = 0;
    
    // 방향 변환: 1=전진, 0=정지, 2=후진
    int left_speed = 0, right_speed = 0;
    
    if (left_dir == 1) left_speed = speed;      // 전진
    else if (left_dir == 2) left_speed = -speed; // 후진
    else left_speed = 0;                         // 정지
    
    if (right_dir == 1) right_speed = speed;     // 전진
    else if (right_dir == 2) right_speed = -speed; // 후진
    else right_speed = 0;                        // 정지
    
    motor_state.left_speed = left_speed;
    motor_state.right_speed = right_speed;
    
    set_motor_speed(left_speed, right_speed);
}

// 모터 속도 설정
void set_motor_speed(int left_speed, int right_speed)
{
    // 왼쪽 모터 (PB0=IN1, PB1=IN2, PA8=ENA)
    if (left_speed > 0)
    {
        // 정방향
        GPIOB->BSRR = (1 << 0);   // IN1 = 1
        GPIOB->BRR = (1 << 1);    // IN2 = 0
    }
    else if (left_speed < 0)
    {
        // 역방향
        GPIOB->BRR = (1 << 0);    // IN1 = 0
        GPIOB->BSRR = (1 << 1);   // IN2 = 1
    }
    else
    {
        // 정지
        GPIOB->BRR = (1 << 0) | (1 << 1);
    }
    
    TIM1->CCR1 = (left_speed < 0) ? -left_speed : left_speed;
    
    // 오른쪽 모터 (PB2=IN3, PB3=IN4, PA7=ENB)
    if (right_speed > 0)
    {
        // 정방향
        GPIOB->BSRR = (1 << 2);   // IN3 = 1
        GPIOB->BRR = (1 << 3);    // IN4 = 0
    }
    else if (right_speed < 0)
    {
        // 역방향
        GPIOB->BRR = (1 << 2);    // IN3 = 0
        GPIOB->BSRR = (1 << 3);   // IN4 = 1
    }
    else
    {
        // 정지
        GPIOB->BRR = (1 << 2) | (1 << 3);
    }
    
    TIM3->CCR2 = (right_speed < 0) ? -right_speed : right_speed;
    
    // 변경 사항을 UART로 전송
    on_motor_speed_changed(left_speed, right_speed);
}

// 모터 속도 변경 콜백
void delay_ms(uint32_t ms)
{
    for (uint32_t i = 0; i < ms * 8000; i++)
        __asm__("nop");
}

// 모터 속도 변경 콜백 (UART로 변경된 값 전송)
void on_motor_speed_changed(int left_speed, int right_speed)
{
    uart_puts("OK:L=");
    
    // 왼쪽 방향/속도
    if (left_speed > 0) uart_puts("FWD,");
    else if (left_speed < 0) uart_puts("REV,");
    else uart_puts("STOP,");
    
    uart_puts("R=");
    
    // 오른쪽 방향/속도
    if (right_speed > 0) uart_puts("FWD");
    else if (right_speed < 0) uart_puts("REV");
    else uart_puts("STOP");
    
    uart_puts("\r\n");
}

int main(void)
{
    // 시스템 클럭 초기화 (HSI 8MHz)
    system_clock_init();
    
    // 주변장치 초기화
    uart_init();
    gpio_init();
    timer_init();
    
    uart_puts("Motor Control System Started\r\n");
    uart_puts("Format: speed,left_dir,right_dir\r\n");
    uart_puts("Dir: 1=forward, 0=stop, 2=reverse\r\n");
    uart_puts("Example: 100,1,2 (speed=100, L=fwd, R=rev)\r\n");
    uart_puts("Ready\r\n");
    
    // 메인 루프
    while (1)
    {
        uart_rx_handler();
    }
    
    return 0;
}
